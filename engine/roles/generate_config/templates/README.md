This folder contains jinja2 templates for rendering the OMNeT++ files for simulation. [scenario.j2](scenario.j2) and [topo.j2](topo.j2) are included by the generations scripts. scenario.j2 recursively includes the other templates. It directly includes [nodes.j2](nodes.j2), [network.j2](network.j2), [actions.j2](actions.j2), [stack.j2](stack.j2), and [experiment.j2](experiment.j2). Each subtemplate generates a ini file section that are combined in the final experiment sections, that realize the experiment. The former two are independent of the experiment and are included only once, while the latter two are experiment specific and are included for each experiment. network.j2 includes the two subtemplates [flows.j2](flows.j2) and [tsn.j2](tsn.j2) which generate independent portions of the config. tsn.j2 includes templates from [queues_mode](queues_mode), based on the modes used for queues. stack.j2 includes templates from [services](services) based on the services actually in use. The folder services further contains additional tempates for common functionality.

# Development notes

The generated simulation configurations make use of OMNeT++'s ini file sections to reuse the node and network configurations and replicate the structure of the underlying variable files, with experiments referencing networks and stacks. The hierarchy of the templates is similar to that of the scenario variable files, and there is one template per variable file, implementing the configuration for this variable file, including other templates.
Services might reference flows or interfaces and the actual addresses or interfaces to be used and configured thus depend on the specific network that is used for the experiment. Thus only relevant stack configurations are generated per experiment and the respective ini section can then be used by the experiment. Same for actions, which currently aren't implemented. Since this is not the case for the network configuration, network.j2 is included only once, and generates the config for all defined networks, independent of their actual usage. General config that is not related to any of the variable files should either be added to nodes.j2, if it is dependent on the actual nodes in use, or scenario.j2.
The folders queue_modes and services contain templates that are named after the actual queue modes, i.e. qdiscs, and service name parameters in use. They are included based on these values used in the variable files. They can be easily extended by adding new files with the correct name to the respective folder. 
Since there are currently only two root level qdiscs in use, taprio and mqprio, where mqprio is default and use of taprio can be indicated with an optional dict, these are currently hardcoded with mqprio being the default configured in the underlying ned files. If more root level qdiscs are going to be implemented, refactoring this might be worth consideration.
To implement a new service, a corresponding template file has to be created. Services might have impact on common configuration parameters and thus a standalone implementation isn't possible. These currently include the nodes' submodule parameters device.numApps, device.bridging.streamIdentifier.identifier.mapping, device.bridging.streamCoder.encoder.mapping, and switch.eth.macLayer.numPcapRecorders. The current approach is to have a respective dict (named by replacing '.' with underscore) with entries for each node, storing the respective value. This dict can then be modified by the service template, making relevant modifications, i.e. adding a value or appending a string. The additional dict device_numServices counts the number of services and can be used for comments or app's display_string paramter. The lines setting these common parameters will then be generated in the stacks.j2 template, after the service specific configurations. The services folder contains additional files for implementing functionality shared between services. The current templates require additional variables to be set before including them, to facilitate generation based on these paramters. This currently includes io_app.j2, which is used by services using a UdpApp like module for traffic generation or receiving, to implement setup of the io submodule, and tsn_app.j2, to set up the custom modules for the send_udp service. Some templates might also implement shared processing functionality. iface_flow_flows.j2 calculates actual interfaces to be used based on service stack parameters, which is currently required for the tcpdump service. Similar to the approach for common variables between services, this requires a variable to be set beforehand, which the template can use to store the interfaces.
The externally defined variables to be used in the templates are currently collected in the generate_context methods of the respective script rendering the templates. Additional functions for precalculating required values are defined in the process_variables.py script and added to the other variables in the access_variables.py script, which loads and preprocesses the basic variable files. The variables contain the scenario variables, extended with the precalculated values and incuding variables from referenced topology files and default values. The additional dicts host_vars and group_vars contain the variables for each host and group. The additional variables scene and comments hold the values passed as argument. Scene gives the scenario name and comments can be used to indicate a level which can be used for conditionally including comments in the generated file.
